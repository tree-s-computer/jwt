# JWT

JWT 표준 문서 [rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)

# Abstract

**JSON 웹 토큰(JWT)**은 간결하고 URL에 안전한 방식으로 클레임을 표현하는 간결하고 안전한 수단입니다. JWT의 클레임은 JSON 구조의 페이로드로 사용되는 JSON 객체로 인코딩됩니다.
웹 서명(JWS) 구조의 페이로드로 사용되거나 JSON Web 암호화(JWE) 구조의 일반 텍스트로 인코딩되어 클레임이 디지털로 서명되거나 디지털 서명 또는 무결성 보호 메시지 인증 코드
(MAC) 및/또는 암호화할 수 있습니다.

1. Header(헤더): 토큰의 타입 및 암호화 알고리즘과 같은 메타데이터를 포함합니다.
2. Payload(페이로드): 클레임이라고 불리는 정보의 실제 내용이 이 부분에 담겨 있습니다. 이 부분에는 등록된 클레임, 공개 클레임 및 비공개 클레임이 포함될 수 있습니다.
3. Signature(서명): 헤더와 페이로드를 사용하여 생성되는 서명으로, 토큰이 변경되지 않았음을 검증하는 데 사용됩니다.

# Introduction

JSON [RFC7159] 개체로 전송하며, 이 개체는 JSON 웹 서명 토큰의 JSON 웹 서명(JWS) [JWS] 구조의 페이로드로 사용되거나 JSON 웹 암호화(JWE) [JWE] 구조의 일반 텍스트로 전송할 수 있습니다.

디지털 서명 또는 무결성 보호를 위해 클레임이 디지털 서명되거나
메시지 인증 코드(MAC) 및/또는 암호화할 수 있습니다.

# 1 등록된 (registered) 클레임

등록된 클레임들은 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기위하여 이름이 이미 정해진 클레임들입니다. 등록된 클레임의 사용은 모두 선택적 (optional)이며, 이에 포함된 클레임 이름들은 다음과 같습니다:

iss: 토큰 발급자 (issuer)
sub: 토큰 제목 (subject)
aud: 토큰 대상자 (audience)
exp: 토큰의 만료시간 (expiraton), 시간은 NumericDate 형식으로 되어있어야 하며 (예: 1480849147370) 언제나 현재 시간보다 이후로 설정되어있어야합니다.
nbf: Not Before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.
iat: 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age 가 얼마나 되었는지 판단 할 수 있습니다.
jti: JWT의 고유 식별자로서, 주로 중복적인

# 2 공개 (public) 클레임

공개 클레임들은 충돌이 방지된 (collision-resistant) 이름을 가지고 있어야 합니다. 충돌을 방지하기 위해서는, 클레임 이름을 URI 형식으로 짓습니다.

{
"https://velopert.com/jwt_claims/is_admin": true
}

# 3 비공개 (private) 클레임

등록된 클레임도아니고, 공개된 클레임들도 아닙니다. 양 측간에 (보통 클라이언트 <->서버) 협의하에 사용되는 클레임 이름들입니다. 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용할때에 유의해야합니다.

{
"username": "velopert"
}

# 예제 Payload

{
"iss": "velopert.com",
"exp": "1485270000000",
"https://velopert.com/jwt_claims/is_admin": true,
"userId": "11028373727102",
"username": "velopert"
}

# 어떤 상황에서 사용될까?

## 회원 인증

JWT를 사용하는 가장 흔한 시나리오입니다. 유저가 로그인을 하면, 서버는 유저의 정보에 기반한 토큰을 발급하여 유저에게 전달해줍니다. 그 후, 유저가 서버에 요청을 할 때마다 JWT를 포함하여 전달합니다. 서버가 클라이언트에게서 요청을 받을 때마다, 해당 토큰이 유효하고 인증됐는지 검증을 하고, 유저가 요청한 작업에 권한이 있는지 확인하여 작업을 처리합니다. 즉, 서버 측에서는 유저의 세션을 유지할 필요가 없습니다. 유저가 로그인되어있는지 안되어있는지 신경 쓸 필요가 없고, 유저가 요청을 했을 때 토큰만 확인하면 되니, 세션 관리가 필요 없어서 서버 자원을 많이 아낄 수 있습니다.

## 정보 교류

JWT는 두 개체 사이에서 안정성 있게 정보를 교환하기에 좋은 방법입니다. 그 이유는, 정보가 sign 이 되어있기 때문에 정보를 보낸 이 가 바뀌진 않았는지, 또 정보가 도중에 조작되지는 않았는지 검증할 수 있습니다.

# Glossary for JWT

### 클레임

클레임은 주로 **사용자, 권한, 기간, 발급자 및 기타 특정 정보**를 나타내는 데 사용됩니다. 예를 들어, 토큰이 사용자의 ID, 권한, 토큰의 만료 시간 등을 포함할 수 있습니다. **클레임**은 토큰을 사용하는 어플리케이션이나 **서비스에서 필요한 정보를 전달**하는 데 사용되며, 토큰을 **검증**할 때 이 정보를 사용하여 요청의 유효성을 확인합니다

### 공개 클레임 이름

클레임 이름은 JWT를 사용하는 사람이 임의로 정의할 수 있습니다. 그러나 충돌을 방지하기 위해 새로운 클레임 이름은 다음과 같아야 합니다.
10.1항에 의해 설립된 IANA "JSON 웹 토큰 클레임" 레지스트리에 등록되거나 등록하거나 공개 이름이어야 합니다.
충돌 방지 이름. 각각의 경우, 이름 또는 값의 정의자는 값의 정의자는 합리적인 예방 조치를 취해야 합니다.
클레임을 정의하는 데 사용하는 네임스페이스의 일부를 제어해야 합니다.

### 비공개 클레임 이름

JWT의 생산자와 소비자는 다음과 같은 클레임 이름을 사용하는 데 동의할 수 있습니다.
비공개 이름: 등록된 클레임 이름이 아닌 이름.

### 공간 제약

공간 제약이란 주로 네트워크 대역폭, 디바이스의 메모리, 저장 공간 등에 관련된 제한적인 자원을 나타냅니다. HTTP는 텍스트 기반의 프로토콜이기 때문에 데이터 전송 시에 일정한 부가적인 오버헤드가 발생하며, 이는 제한된 네트워크 대역폭이나 디바이스 저장 공간에 영향을 미칠 수 있습니다.

JWT가 HTTP와 관련이 있는 이유는 JWT가 클레임을 표현하는데 있어서, **HTTP와 같은 공간 제약이 있는 환경에서도 효율적으로 정보를 전송하기 위한 목적으로 디자인되었기 때문**입니다. JWT는 데이터를 컴팩트하게 표현할 수 있고, Base64 인코딩을 사용하여 텍스트 기반의 표현을 간소화합니다. 이러한 특성은 HTTP 헤더나 URI 쿼리 매개변수 등과 같이 제한된 공간에서도 효과적으로 사용될 수 있도록 도와줍니다.

### 대역폭

대역폭(Bandwidth)은 네트워크에서 단위 **시간당 전송 가능한 데이터 양**을 나타내는 용어입니다.

일반적으로 초당 비트(bps, bits per second) 또는 바이트(B/s 또는 Bps, bytes per second)로 측정됩니다. 대역폭은 네트워크 연결의 속도를 나타내며, 높은 대역폭은 더 빠른 데이터 전송을 의미합니다.

더 구체적으로, 대역폭은 특정 통신 매체(예: 인터넷 회선, 이더넷 케이블, 무선 네트워크 등)를 통해 전송되는 데이터의 양을 의미합니다. **대역폭이 크면 더 많은 데이터가 동시에 전송될 수 있으므로**, 빠르고 효율적인 통신이 가능해집니다.

### 무결성

무결성(Integrity)은 **데이터가 변조되지 않았음**을 보장하는 보안 속성입니다. 무결성 보호는 데이터가 전송되거나 저장되는 동안에도 그 내용이 변경되지 않았음을 확인하고 유지하는 것을 의미합니다. 무결성이 보호되면 데이터가 의도치 않게 수정되거나 손상되는 것을 방지할 수 있습니다.

**무결성 보호를 위해** 사용되는 다양한 기술 중 하나가 **디지털 서명(Digital Signature)**입니다. 디지털 서명은 특정 데이터의 무결성과 인증을 담당하는 암호 기술입니다. 이것은 비공개 키(Private Key)를 사용하여 메시지에 서명하고, 이 서명을 공개 키(Public Key)를 통해 검증함으로써 메시지의 무결성을 확인합니다. 변조되지 않은 원본 메시지를 사용하여 같은 서명을 재생성할 수 없기 때문에, 디지털 서명이 있는 메시지는 무결성이 보장된 것으로 간주됩니다.

JSON Web Token(JWT)에서도 무결성 보호가 중요한 역할을 합니다. JWT의 페이로드(클레임)와 헤더는 **디지털 서명으로 보호되어 있습니다.** 토큰을 생성하는 측에서는 비밀 키를 사용하여 서명을 생성하고, 토큰을 검증하는 측에서는 해당 비밀 키를 사용하여 서명이 유효한지 확인합니다. 이를 통해 토큰이 변조되지 않았음을 보장하고, 클레임이 신뢰할 수 있는 것으로 간주됩니다.

### MAC

MAC(Message Authentication Code)은 메시지에 대한 인증 코드를 생성하는 것을 의미합니다. 인증 코드는 메시지의 무결성을 보호하기 위해 사용되며, 해당 메시지가 송신자에서 왔음을 확인하는 데 사용됩니다.

### JOSE

JOSE(JOSE stands for JSON 객체의 서명 및 암호화를 위한 표준 명 Object Signing and Encryption)는 JSON세

### JWE (Json Web Encryption)

서버와 클라이언트 간 암호화된 데이터를 토큰화 한 것

### JWK (Json Web Key)

JWE 에서 payload encryption에 쓰인 키를 토큰화 한 것

### 단방향 암호화

**단방향 암호화의 가장 간단한 방식은 해시 함수를 사용하는 것입니다.**

- 같은 알고리즘과 같은 인코딩 방식을 사용하면 같은 비밀번호에 대해 같은 결과를 반환한다는 것을 알 수 있습니다.
- 해커가 모든 암호에 대해 어떤 결과가 나올지 데이터베이스화 해두었다면, 결과만 보고도 원래 암호를 유추해낼 수 있습니다.
- 따라서 해커가 레인보우 테이블을 사용하지 못하게 하는 방법이 필요합니다.(할 수는 있지만 수 십, 수 백년의 시간이 걸립니다) 바로 **소금**을 뿌려주면 됩니다.

### 양방향 암호화

- **비대칭형 암호화**
- **대칭형 암호화**

# 레퍼런스

https://velopert.com/2389
